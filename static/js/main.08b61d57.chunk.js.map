{"version":3,"sources":["image/logo.png","reducers/github.js","reducers/index.js","components/DataTypes.js","components/sections/Colors.js","scripts/GithubFetcher.js","components/sections/Repository.js","components/sections/ChartOptions.js","components/sections/Star.js","components/sections/Fork.js","components/sections/Commit.js","components/sections/Release.js","components/sections/Issues.js","components/sections/PullRequests.js","components/DataSection.js","components/GithubStatistics.js","actions/github.js","components/App.js","serviceWorker.js","index.js"],"names":["module","exports","INITIAL_STATE","repoData","repoStats","starData","starStats","forkData","forkStats","releaseData","releaseStats","githubApiToken","github","state","action","type","payload","data","Object","assign","stats","reducers","combineReducers","REPO","STAR","FORK","COMMIT","RELEASE","ISSUES","PULLREQUESTS","getProgress","c","t","Math","floor","GithubFetcher","token","searchRepository","input","onResult","a","variables","query","formattedData","gqlClient","request","search","nodes","forEach","repo","push","nameWithOwner","fetchRepositoryData","owner","name","onUpdate","onFinish","onProgress","shouldAbort","repository","createdAt","primaryLanguage","pushedAt","watcherCount","watchers","totalCount","fetchStargazerData","preparationVariables","preparationQuery","Map","pageIndex","totalToFetch","maxIncrement","numberFetched","previousEndCursor","hasNextPage","preparationData","stargazers","handleEdge","edge","date","Date","starredAt","slice","getTime","has","set","get","Promise","resolve","_data","setTimeout","edges","pageInfo","endCursor","liveUpdate","pagesPerUpdate","total","fetchForkData","forks","handleNode","node","fetchRequestsData","pullRequests","fetchIssuesData","issues","fetchCommitData","defaultBranchRef","target","history","headRefOid","oid","since","committedDate","setFullYear","getFullYear","toISOString","object","fetchReleaseData","totalDownloads","console","log","releases","releaseAssets","asset","id","updatedAt","contentType","downloadCount","totalAssets","tagName","this","GraphQLClient","headers","Authorization","Repository","_render","props","ready","Array","from","entries","map","pair","index","dateSinceCreated","now","valueOf","key","color","COLORS","align","justify","className","title","value","toDateString","moment","fromNow","prefix","React","Component","text","undefined","legend","itemStyle","fontWeight","colors","tooltip","shadow","split","credits","enabled","Star","_renderStatistics","Fragment","averagePerDay","precision","_renderCharts","values","includes","highcharts","Highcharts","options","OPTIONS","chart","events","selection","event","resetSelection","setState","arr","cloneMap","min","xAxis","max","resetData","zoomType","yAxis","gridLineWidth","series","dataArray","isReset","nextProps","loading","obj","create","k","v","JSON","parse","stringify","tmpMap","keys","initial","formatter","increment","cumulativeCount","Fork","Commit","reverse","Release","averageDownloadsPerDay","columns","dataSource","pagination","dataIndex","render","time","format","arrayObj","sort","b","DataSection","_fetch","repos","slashIndex","indexOf","fetchCall","_getAllProgress","progress","reduce","size","_renderUpdateAllButton","icon","fontSize","lineHeight","length","_renderRepoTags","visible","style","display","percent","showInfo","strokeWidth","width","checked","onChange","_renderBody","body","fetcher","TYPES","info","Issues","PullRequests","prevProps","deleteRepo","delete","filter","content","placement","marginLeft","connect","GithubStatistics","splice","localStorage","setItem","addRepo","message","error","_renderTags","closable","onClose","rel","href","_renderHeaderInput","testingRepo","suggestions","hintMessage","inputEmpty","repoExisted","disabled","placeholder","defaultActiveFirstOption","onSearch","notFoundContent","showArrow","filterOption","showSearch","Option","onClick","updateState","_","debounce","leading","trailing","bind","getItem","src","frameBorder","scrolling","height","_target","logo","alt","bounds","offsetTop","Link","dispatch","App","Boolean","window","location","hostname","match","store","createStore","ReactDOM","document","getElementById","navigator","serviceWorker","then","registration","unregister"],"mappings":"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","file":"static/js/main.08b61d57.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.09e6b94d.png\";","const INITIAL_STATE = {\n  repoData: [],\n  repoStats: {},\n\n  starData: [],\n  starStats: {},\n\n  forkData: [],\n  forkStats: {},\n\n  releaseData: [],\n  releaseStats: {},\n\n  githubApiToken: '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',\n\n}\n\nconst github = (state = INITIAL_STATE, action) => {\n  const { type, payload } = action\n  switch (type) {\n    case 'UPDATE_STATE':\n      return {\n        ...state,\n        ...{[payload.state]: payload.data}\n      }\n    case 'UPDATE_STATS_FIELD':\n      return Object.assign({}, state, {\n        [payload.state] : {\n          ...state[payload.state],\n          ...payload.stats\n        }\n      })\n    default:\n      return state\n  }\n}\n\nexport default github","import { combineReducers } from 'redux'\n\nimport github from './github'\n\nconst reducers = combineReducers({\n  github: github,\n})\n\nexport default reducers","/**\n * Keys are used for reference\n * Values are used for displaying and passing\n */\n\nexport default {\n  REPO: 'Repository',\n  STAR: 'Star',\n  FORK: 'Fork',\n  COMMIT: 'Commit',\n  RELEASE: 'Release',\n  ISSUES: 'Issues',\n  PULLREQUESTS: 'Pull Requests',\n}","export default [\n  '#A2B449',\n  '#E89A41',\n  '#9EABCD',\n  '#56BABD',\n  '#D79AB3',\n  '#E6978A',\n  '#5EBE85',\n]","import {  } from 'graphql'\nimport { GraphQLClient } from 'graphql-request'\n\nconst getProgress = (c, t) => t === 0 ? 100 : Math.floor(c / t * 100)\n\nclass GithubFetcher {\n\n  constructor(token) {\n    const endpoint = 'https://api.github.com/graphql'\n\n    this.gqlClient = new GraphQLClient(\n      endpoint,\n      {\n        headers: {\n          Authorization: 'bearer ' + token,\n        }\n      }\n    )\n\n    // configurations\n    this.liveUpdate = false\n    this.pagesPerUpdate = 20\n  }\n\n  /**\n   * test if the repository exists\n   * @param owner owner of the repository\n   * @param name of the repository\n   * @param onResult (@param result) function that will be called when test finishes\n   * @return false if not exist, true otherwise\n   */\n  // testRepository = async (owner, name, onResult) => {\n  //   const variables = {\n  //     owner: owner,\n  //     name: name,\n  //   }\n\n  //   const query = /* GraphQL */ `\n  //     query getRepository($owner: String!, $name: String!){\n  //       repository(owner: $owner, name: $name) {\n  //         id\n  //       }\n  //     }\n  //   `\n\n  //   try {\n  //     await this.gqlClient.request(query, variables)\n  //   } catch (error) {\n  //     if (onResult) {\n  //       onResult(false)\n  //     }\n  //     return false\n  //   }\n\n  //   if (onResult) onResult(true)\n  //   return true\n  // }\n\n  /**\n   * suggest possible repositories based on current input\n   * @param onResult (@param result) function that will be called when search finishes\n   */\n  searchRepository = async (input, onResult) => {\n    const variables = {\n      query: input,\n    }\n\n    const query = /* GraphQL */ `\n      query searchRepository($query: String!){\n        search(query: $query, first: 5, type: REPOSITORY) {\n          codeCount\n          nodes {\n            ...on Repository {\n              nameWithOwner\n            }\n          }\n        }\n      }\n    `\n    let formattedData = []\n\n    const data = await this.gqlClient.request(query, variables)\n\n    data.search.nodes.forEach(repo => formattedData.push(repo.nameWithOwner))\n\n    if (onResult) onResult(formattedData)\n\n    return formattedData\n  }\n\n  /**\n   * fetch repository low-level data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchRepositoryData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const variables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const query = /* GraphQL */ `\n      query getRepository($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          nameWithOwner\n          createdAt\n          primaryLanguage {\n            name\n          }\n          pushedAt\n          watchers(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n\n    // update progress tracking\n    if (onProgress) onProgress(10)\n\n    const data = await this.gqlClient.request(query, variables)\n    // if (shouldAbort) {\n    //   if (shouldAbort()) {\n    //     return\n    //   }\n    // }\n\n    const formattedData = {\n      name: data.repository.nameWithOwner,\n      createdAt: data.repository.createdAt,\n      primaryLanguage: data.repository.primaryLanguage.name,\n      pushedAt: data.repository.pushedAt,\n      watcherCount: data.repository.watchers.totalCount,\n    }\n\n    // update progress tracking\n    if (onProgress) onProgress(100)\n\n    if (onFinish) onFinish(formattedData)\n\n    return formattedData\n  }\n\n  /**\n   * fetch repository low-level data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchStargazerData = async (owner, name, onUpdate = () => {}, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareStargazers($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          createdAt\n          stargazers(first: 100) {\n            totalCount\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getStargazers($owner: String!, $name: String!, $previousEndCursor: String){\n        repository(owner: $owner, name: $name) {\n          stargazers(first: 100, after: $previousEndCursor) {\n            pageInfo {\n              endCursor\n              hasNextPage\n            }\n            edges {\n              starredAt\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let maxIncrement = 0\n    let numberFetched = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.stargazers.totalCount\n    const createdAt = preparationData.repository.createdAt\n\n    const handleEdge = edge => {\n      const date = new Date(edge.starredAt.slice(0,10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await new Promise(resolve => {\n        const _data = this.gqlClient.request(query, variables)\n        setTimeout(() => resolve(_data), 255)\n      })\n\n      data.repository.stargazers.edges.forEach(handleEdge)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.stargazers.pageInfo.endCursor\n      hasNextPage = data.repository.stargazers.pageInfo.hasNextPage\n      // update pageIndex\n      pageIndex += 1\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt,\n    })\n    return formattedData\n  }\n\n  /**\n   * fetch fork data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchForkData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareForks($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          createdAt\n          forkCount\n          forks(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getForks($owner: String!, $name: String!, $previousEndCursor: String){\n        repository(owner: $owner, name: $name) {\n          forks(first: 100, after: $previousEndCursor) {\n            pageInfo {\n              endCursor\n              hasNextPage\n            }\n            nodes {\n              createdAt\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let maxIncrement = 0\n    let numberFetched = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.forks.totalCount\n    const createdAt = preparationData.repository.createdAt\n\n\n\n    const handleNode = node => {\n      const date = new Date(node.createdAt.slice(0,10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      data.repository.forks.nodes.forEach(handleNode)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.forks.pageInfo.endCursor\n      hasNextPage = data.repository.forks.pageInfo.hasNextPage\n\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt,\n    })\n\n    return formattedData\n  }\n\n  /**\n * fetch repository low-level data\n * @param owner owner of the repository\n * @param name name of the repository\n * @param onUpdate (data) function that will be called when a new data update is avaiable\n * @param onFinish (stats) function that will be called when fetching is finished\n * @param onProgress (progress) function that will be called when progress is updated\n * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n * @returns Object that contains statistics\n */\n  fetchRequestsData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareForks($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          createdAt\n          forkCount\n          pullRequests(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getForks($owner: String!, $name: String!, $previousEndCursor: String){\n        repository(owner: $owner, name: $name) {\n          pullRequests(first: 100, after: $previousEndCursor) {\n            pageInfo {\n              endCursor\n              hasNextPage\n            }\n            nodes {\n              createdAt\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let maxIncrement = 0\n    let numberFetched = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.pullRequests.totalCount\n    const createdAt = preparationData.repository.createdAt\n\n\n\n    const handleNode = node => {\n      const date = new Date(node.createdAt.slice(0, 10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      data.repository.pullRequests.nodes.forEach(handleNode)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.pullRequests.pageInfo.endCursor\n      hasNextPage = data.repository.pullRequests.pageInfo.hasNextPage\n\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt,\n    })\n\n    return formattedData\n  }\n\n  /**\n * fetch repository low-level data\n * @param owner owner of the repository\n * @param name name of the repository\n * @param onUpdate (data) function that will be called when a new data update is avaiable\n * @param onFinish (stats) function that will be called when fetching is finished\n * @param onProgress (progress) function that will be called when progress is updated\n * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n * @returns Object that contains statistics\n */\n  fetchIssuesData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareForks($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          createdAt\n          forkCount\n          issues(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getForks($owner: String!, $name: String!, $previousEndCursor: String){\n        repository(owner: $owner, name: $name) {\n          issues(first: 100, after: $previousEndCursor) {\n            pageInfo {\n              endCursor\n              hasNextPage\n            }\n            nodes {\n              createdAt\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let maxIncrement = 0\n    let numberFetched = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.issues.totalCount\n    const createdAt = preparationData.repository.createdAt\n\n\n\n    const handleNode = node => {\n      const date = new Date(node.createdAt.slice(0, 10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      data.repository.issues.nodes.forEach(handleNode)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.issues.pageInfo.endCursor\n      hasNextPage = data.repository.issues.pageInfo.hasNextPage\n\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt,\n    })\n\n    return formattedData\n  }\n\n  /**\n   * fetch repository low-level data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchCommitData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareCommits($owner: String!, $name: String!) {\n        repository(owner: $owner, name: $name) {\n          defaultBranchRef {\n            # name\n            target {\n              ... on Commit {\n                oid\n                committedDate\n                history {\n                  totalCount\n                }\n              }\n            }\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getCommits($owner: String!, $name: String!, $previousEndCursor: String, $oid: GitObjectID!, $since: GitTimestamp!){\n        repository(owner: $owner, name: $name) {\n          object(oid: $oid) {\n            ... on Commit {\n              history(first: 100, after: $previousEndCursor, since: $since ) {\n                totalCount\n                pageInfo {\n                  endCursor\n                  hasNextPage\n                }\n                nodes {\n                  committedDate\n                  # message\n                }\n              }\n            }\n          }\n        }\n      }\n    `\n\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let numberFetched = 0\n    let maxIncrement = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.defaultBranchRef.target.history.totalCount\n    const headRefOid = preparationData.repository.defaultBranchRef.target.oid\n    const since = new Date(new Date(preparationData.repository.defaultBranchRef.target.committedDate)\n      .setFullYear(new Date(preparationData.repository.defaultBranchRef.target.committedDate).getFullYear() - 1))\n      .toISOString()\n\n    const handleNode = node => {\n      const date = new Date(node.committedDate.slice(0,10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        oid: headRefOid,\n        since: since,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      totalToFetch = data.repository.object.history.totalCount\n      data.repository.object.history.nodes.forEach(handleNode)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.object.history.pageInfo.endCursor\n      hasNextPage = data.repository.object.history.pageInfo.hasNextPage\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt: since,\n    })\n\n    return formattedData\n  }\n\n  /**\n   * fetch release data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchReleaseData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const variables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const query = /* GraphQL */ `\n      query getRelease($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          releases(first: 1, orderBy:{field:CREATED_AT,direction: DESC}) {\n            totalCount\n            nodes {\n              name\n              tagName\n              createdAt\n              releaseAssets (first: 20) {\n                totalCount\n                nodes {\n                  id\n                  name\n                  updatedAt\n                  contentType\n                  createdAt\n                  downloadCount\n                  \n                }\n              }\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = []\n    let totalToFetch = 0\n    let numberFetched = 0\n    let totalDownloads = 0\n\n    // Preparation query\n    const data = await this.gqlClient.request(query, variables)\n    // if (shouldAbort) {\n    //   if (shouldAbort()) {\n    //     return\n    //   }\n    // }\n    console.log(data)\n    if (data.repository.releases.totalCount !== 0) {\n      // from preparation\n      totalToFetch = data.repository.releases.nodes[0].releaseAssets.totalCount\n\n      // get stats of each asset\n      data.repository.releases.nodes[0].releaseAssets.nodes.forEach(asset => {\n        formattedData.push({\n          id: asset.id,\n          name: asset.name,\n          updatedAt: asset.updatedAt,\n          contentType: asset.contentType,\n          createdAt: asset.createdAt,\n          downloadCount: asset.downloadCount,\n        })\n\n        totalDownloads += asset.downloadCount\n\n        numberFetched += 1\n        if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n      })\n\n      if (onProgress) onProgress(100)\n\n      if (onUpdate) onUpdate(formattedData)\n\n      if (onFinish) onFinish({\n        totalAssets: totalToFetch,\n        totalDownloads: totalDownloads,\n        name: data.repository.releases.nodes[0].name,\n        tagName: data.repository.releases.nodes[0].tagName,\n        createdAt: data.repository.releases.nodes[0].createdAt\n      })\n    } else {\n      if (onProgress) onProgress(100)\n\n      if (onUpdate) onUpdate(formattedData)\n\n      if (onFinish) onFinish({\n        totalAssets: totalToFetch,\n        totalDownloads: totalDownloads,\n      })\n    }\n\n    return formattedData\n  }\n}\n\nexport default GithubFetcher","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport moment from 'moment'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n\nimport COLORS from './Colors'\n\nclass Repository extends React.Component {\n\n  _render = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { name, createdAt, primaryLanguage, pushedAt, watcherCount } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n\n            return (\n              <div key={`repo-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                </Row>\n                <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Repository\" value={name} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Date created\" value={new Date(createdAt).toDateString()} />                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Days since created\" value={dateSinceCreated} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Primary language\" value={primaryLanguage} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Last push at\" value={moment(pushedAt).fromNow()} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Watchers\" prefix={<Icon type=\"eye\"/>} value={watcherCount} />\n                  </span>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._render()}\n      </>\n    )\n  }\n}\n\nRepository.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n}\n\n\nexport default Repository","/**\n * Common highchart options shared by\n * most of the charts\n */\n\nimport COLORS from './Colors'\n\nexport default {\n  title: {\n    text: undefined,\n  },\n  // xAxis: {\n  //   type: 'datetime',\n  // },\n  legend: {\n    itemStyle: {\n      color: 'rgba(0, 0, 0, 0.85)',\n      fontWeight: '300'\n    }\n  },\n  colors: COLORS,\n  tooltip: {\n    shadow: false,\n    split: true,\n  },\n  credits: {\n    enabled: false,\n  },\n}","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Star extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      isReset: false,\n      arr: []\n    }\n  }\n  static formatter = (repo, data) => {\n    // star total data, index 0\n    let total = { name: repo, data: [] }\n    // star  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n\n    let cumulativeCount = 0\n    data.forEach((value, key) => {\n      cumulativeCount += value\n      total.data.push([key, cumulativeCount])\n      increment.data.push([key, value])\n    })\n\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n  cloneMap(map) {\n    let obj = Object.create(null)\n    for (let [k, v] of map) {\n      obj[k] = v\n    }\n    obj = JSON.parse(JSON.stringify(obj))\n    let tmpMap = new Map()\n    for (let k of Object.keys(obj)) {\n      console.log(obj[k])\n      tmpMap.set(k, obj[k])\n    }\n    return tmpMap\n  }\n  static getDerivedStateFromProps(nextProps) {\n    const { data } = nextProps\n    let obj = Object.create(null)\n    for (let [k, v] of data) {\n      obj[k] = v\n    }\n    obj = JSON.parse(JSON.stringify(obj))\n    let arr = new Map()\n    for (let k of Object.keys(obj)) {\n      console.log(k, obj[k])\n      arr.set(k, obj[k])\n    }\n    return {\n      arr,\n    }\n  }\n\n  resetData(min, max) {\n    Array.from(this.state.arr.values()).map(dataArray => dataArray[0]).forEach((value, index) => {\n      let initial = 0\n      value.data.forEach((obj, index) => {\n        if (min <= obj[0] && max >= obj[0]) {\n          if (!initial) {\n            initial = obj[1]\n            value.data[index-1] = 0\n          }\n        }\n        if (obj) {\n          obj[1] -= initial\n        }\n      })\n    })\n    this.setState({\n      isReset: true\n    })\n  }\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <React.Fragment>\n        {Array.from(stats.entries()).map((\n          (pair, index) => {\n            if (ready.get(pair[0])) {\n              const { total, maxIncrement, createdAt } = pair[1]\n              const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24 * 60 * 60 * 1000))\n              const averagePerDay = total / dateSinceCreated\n              return (\n                <div key={`star-statistics-${pair[0]}`}>\n                  <Row>\n                    <Tag color={COLORS[index]}>\n                      {pair[0]}\n                    </Tag>\n                    <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                      <span className=\"stats-card\">\n                        <Statistic title=\"Total stars\" value={total} prefix={<Icon type=\"star\" />} />\n                      </span>\n                      <span className=\"stats-card\">\n                        <Statistic title=\"Avg. stars/day\" value={averagePerDay} precision={2} />\n                      </span>\n                      <span className=\"stats-card\">\n                        <Statistic title=\"Max. stars/day\" value={maxIncrement} />\n                      </span>\n                    </Row>\n                  </Row>\n                </div>\n              )\n            }\n            return false\n          }\n        ))}\n      </React.Fragment>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready } = this.props\n    if (!Array.from(ready.values()).includes(true)) return\n    return (\n      <React.Fragment>\n        <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              events: {\n                selection: (event) => {\n                  if (!event.resetSelection) {\n                    var min = event.xAxis[0].min\n                    var max = event.xAxis[0].max\n                    this.resetData(min, max)\n                  } else {\n                    this.setState({\n                      arr: this.cloneMap(data)\n                    })\n                  }\n                }\n              },\n              zoomType: 'x',\n              type: 'line'\n            },\n            xAxis: {\n              type: 'datetime',\n            },\n            yAxis: {\n              gridLineWidth: 0,\n              title: {\n                text: 'total stars',\n              },\n            },\n            series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n          }}\n        />\n        <HighchartsReact\n          highcharts={Highcharts}\n          options={{\n            ...OPTIONS,\n            chart: {\n              type: 'line',\n              zoomType: 'x',\n            },\n            xAxis: {\n              type: 'datetime',\n            },\n            yAxis: {\n              gridLineWidth: 0,\n              title: {\n                text: 'star increment/day',\n              },\n            },\n            series: Array.from(data.values()).map(dataArray => dataArray[1]),\n          }}\n        />\n      </React.Fragment>\n    )\n  }\n\n  // _renderLines = (dataIndex) => {\n  //   const { data, ready } = this.props\n  //   const dataReady = Array.from(ready.values())\n  //   console.log(\"Lines are rendered\")\n  //   return Array.from(data.values()).map((dataArray, index) => (\n  //     dataReady[index]\n  //       ?\n  //       <Line\n  //         type=\"monotone\"\n  //         key={`star-chart-total-${dataArray[dataIndex].name}`}\n  //         data={dataArray[dataIndex].data}\n  //         dataKey=\"value\"\n  //         name={dataArray[dataIndex].name}\n  //         stroke={COLORS[index]}\n  //         dot={false}\n  //       />\n  //       :\n  //     <></>\n  //   ))\n  // }\n\n  // _renderCharts = () => {\n  //   const { ready } = this.props\n\n  //   if (!Array.from(ready.values()).includes(true)) return\n\n  //   return (\n  //     <>\n  //     <Row>\n  //       <div>\n  //         <ResponsiveContainer width=\"100%\" height={300}>\n  //           <LineChart>\n  //             <CartesianGrid stroke=\"#ccc\" strokeDasharray=\"2 7\" />\n  //             <Legend verticalAlign=\"top\"/>\n  //             <XAxis\n  //               dataKey=\"timestamp\"\n  //               scale=\"time\"\n  //               allowDuplicatedCategory={false}\n  //               type=\"number\"\n  //               domain = {['auto', 'auto']}\n  //               tickFormatter={ms => new Date(ms).toISOString().slice(0,10)}\n  //             />\n  //             <YAxis dataKey=\"value\" label={{ value: 'total stars', angle: -90, position: 'insideBottomLeft' }}/>\n  //             <ChartToolTip labelFormatter={ms => new Date(ms).toISOString().slice(0,10)}/>\n  //             {this._renderLines(0)}\n  //           </LineChart>\n  //         </ResponsiveContainer>\n  //       </div>\n  //       <div>\n  //         <ResponsiveContainer width=\"100%\" height={300}>\n  //           <LineChart>\n  //             <CartesianGrid stroke=\"#ccc\" strokeDasharray=\"2 7\" />\n  //             <Legend verticalAlign=\"top\"/>\n  //             <XAxis\n  //               dataKey=\"timestamp\"\n  //               scale=\"time\"\n  //               allowDuplicatedCategory={false}\n  //               type=\"number\"\n  //               domain = {['auto', 'auto']}\n  //               tickFormatter={ms => new Date(ms).toISOString().slice(0,10)}\n  //             />\n  //             <YAxis dataKey=\"value\" label={{ value: 'daily increment', angle: -90, position: 'insideBottomLeft' }}/>\n  //             <ChartToolTip labelFormatter={ms => new Date(ms).toISOString().slice(0,10)}/>\n  //             {this._renderLines(1)}\n  //           </LineChart>\n  //         </ResponsiveContainer>\n  //       </div>\n  //     </Row>\n  //     </>\n  //   )\n  // }\n\n  render() {\n    return (\n      <React.Fragment>\n        {this._renderStatistics()}\n        {this._renderCharts()}\n      </React.Fragment>\n    )\n  }\n}\n\nStar.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Star","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Fork extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      isReset: false,\n      arr: []\n    }\n  }\n  static formatter = (repo, data) => {\n    // fprk total data, index 0\n    let total = { name: repo, data: [] }\n    // fork  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n\n    let cumulativeCount = 0\n    data.forEach((value, key) => {\n      cumulativeCount += value\n      total.data.push([key, cumulativeCount])\n      increment.data.push([key, value])\n    })\n\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n\n  cloneMap(map) {\n    let obj = Object.create(null)\n    for (let [k, v] of map) {\n      obj[k] = v\n    }\n    obj = JSON.parse(JSON.stringify(obj))\n    let tmpMap = new Map()\n    for (let k of Object.keys(obj)) {\n      tmpMap.set(k, obj[k])\n    }\n    return tmpMap\n  }\n\n  componentWillReceiveProps(props) {\n    this.setState({\n      arr: this.cloneMap(props.data)\n    })\n  }\n\n  resetData(min, max) {\n    Array.from(this.state.arr.values()).map(dataArray => dataArray[0]).forEach((value, index) => {\n      let initial = 0\n      value.data.forEach((obj, index) => {\n        if (min <= obj[0] && max >= obj[0]) {\n          if (!initial) {\n            initial = obj[1]\n            value.data[index - 1] = 0\n          }\n        }\n        if (obj) {\n          obj[1] -= initial\n        }\n      })\n    })\n    this.setState({\n      isReset: true\n    })\n  }\n\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { total, maxIncrement, createdAt } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averagePerDay = total / dateSinceCreated\n            return (\n              <div key={`fork-statistics-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                  <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Total forks\" value={total} prefix={<Icon type=\"fork\" />} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Avg. forks/day\" value={averagePerDay} precision={2} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Max. forks/day\" value={maxIncrement} />\n                    </span>\n                  </Row>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready } = this.props\n\n    if (!Array.from(ready.values()).includes(true)) return\n\n    return (\n      <>\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            events: {\n              selection: (event) => {\n                if (!event.resetSelection) {\n                  var min = event.xAxis[0].min;\n                  var max = event.xAxis[0].max;\n                  this.resetData(min, max)\n                } else {\n                  this.setState({\n                    arr: this.cloneMap(data)\n                  })\n                }\n              }\n            },\n            zoomType: 'x',\n            type: 'line'\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'total forks',\n            },\n          },\n          series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n        }}\n      />\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            type: 'column',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'fork increment/day',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[1]),\n        }}\n      />\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._renderStatistics()}\n      {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nFork.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Fork","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Commit extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      isReset: false,\n      arr: []\n    }\n  }\n  static formatter = (repo, data) => {\n    // commit total data, index 0\n    let total = { name: repo, data: [] }\n    // commit  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n\n    let cumulativeCount = 0\n\n    // traversal backwards\n    Array.from(data.entries()).slice().reverse().forEach(\n      pair => {\n        cumulativeCount += pair[1]\n        total.data.push([pair[0], cumulativeCount])\n        increment.data.push([pair[0], pair[1]])\n      }\n    )\n\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n\n  cloneMap(map) {\n    let obj = Object.create(null)\n    for (let [k, v] of map) {\n      obj[k] = v\n    }\n    obj = JSON.parse(JSON.stringify(obj))\n    let tmpMap = new Map()\n    for (let k of Object.keys(obj)) {\n      tmpMap.set(k, obj[k])\n    }\n    return tmpMap\n  }\n\n  componentWillReceiveProps(props) {\n    this.setState({\n      arr: this.cloneMap(props.data)\n    })\n  }\n\n  resetData(min, max) {\n    Array.from(this.state.arr.values()).map(dataArray => dataArray[0]).forEach((value, index) => {\n      let initial = 0\n      value.data.forEach((obj, index) => {\n        if (min <= obj[0] && max >= obj[0]) {\n          if (!initial) {\n            initial = obj[1]\n            value.data[index - 1] = 0\n          }\n        }\n        if (obj) {\n          obj[1] -= initial\n        }\n      })\n    })\n    this.setState({\n      isReset: true\n    })\n  }\n\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { total, maxIncrement, createdAt } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averagePerDay = total / dateSinceCreated\n            return (\n              <div key={`fork-statistics-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                  <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Total commits\" value={total} prefix={<Icon type=\"history\" />} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Avg. commits/day\" value={averagePerDay} precision={2} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Max. commits/day\" value={maxIncrement} />\n                    </span>\n                  </Row>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready } = this.props\n\n    if (!Array.from(ready.values()).includes(true)) return\n\n    return (\n      <>\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            events: {\n              selection: (event) => {\n                if (!event.resetSelection) {\n                  var min = event.xAxis[0].min;\n                  var max = event.xAxis[0].max;\n                  this.resetData(min, max)\n                } else {\n                  this.setState({\n                    arr: this.cloneMap(data)\n                  })\n                }\n              }\n            },\n            zoomType: 'x',\n            type: 'line'\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'total commits',\n            },\n          },\n          series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n        }}\n      />\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            type: 'column',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'commit increment/day',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[1]),\n        }}\n      />\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._renderStatistics()}\n      {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nCommit.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Commit","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport moment from 'moment'\n\nimport { Row, Statistic, Icon, Tag, Table } from 'antd'\n\nimport COLORS from './Colors'\n\nclass Release extends React.Component {\n\n  _render = () => {\n    const { stats, data, ready } = this.props\n\n    return (\n      <>\n      {Array.from(ready.entries()).map((\n        (pair, index) => {\n          if (pair[1]) { // ready\n            const { totalAssets, name, tagName, createdAt, totalDownloads } = stats.get(pair[0])\n\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averageDownloadsPerDay = totalDownloads / dateSinceCreated\n\n            return (\n              <div key={`release-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                </Row>\n                <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Release tag\" value={tagName} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Release name\" value={name} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Total assets\" value={totalAssets} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Total asset downlaods\" value={totalDownloads} prefix={<Icon type=\"download\"/>} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Avg. downloads/day\" value={averageDownloadsPerDay} precision={2} />\n                  </span>\n                </Row>\n                <Row>\n                  <Table columns={columns} dataSource={data.get(pair[0])} pagination={false}/>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._render()}\n      </>\n    )\n  }\n}\n\nconst columns = [\n  {\n    title: 'Asset',\n    dataIndex: 'name',\n    key: 'name',\n  },\n  {\n    title: 'Content type',\n    dataIndex: 'contentType',\n    key: 'contentType',\n  },\n  {\n    title: 'Downloads',\n    dataIndex: 'downloadCount',\n    key: 'downloadCount',\n  },\n  {\n    title: 'Created at',\n    dataIndex: 'createdAt',\n    key: 'createdAt',\n    render: time => moment(time).format(\"MMMM Do YYYY, h:mm:ss a\")\n  },\n  {\n    title: 'Updated at',\n    dataIndex: 'updatedAt',\n    key: 'updatedAt',\n    render: time => moment(time).format(\"MMMM Do YYYY, h:mm:ss a\")\n  },\n\n]\n\n\nRelease.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n}\n\n\nexport default Release","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Fork extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      isReset: false,\n      arr: []\n    }\n  }\n\n  static formatter = (repo, data) => {\n    // issues total data, index 0\n    let total = { name: repo, data: [] }\n    // issues  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n    let cumulativeCount = 0\n    let arrayObj = Array.from(data);\n    arrayObj.sort(function (a, b) {\n      return a[0] - b[0];\n    })\n    arrayObj.forEach((value, key) => {\n      cumulativeCount += value[1]\n      total.data.push([value[0], cumulativeCount])\n      \n      increment.data.push([value[0], value])\n    })\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n\n  cloneMap(map) {\n    let obj = Object.create(null)\n    for (let [k, v] of map) {\n      obj[k] = v\n    }\n    obj = JSON.parse(JSON.stringify(obj))\n    let tmpMap = new Map()\n    for (let k of Object.keys(obj)) {\n      tmpMap.set(k, obj[k])\n    }\n    return tmpMap\n  }\n\n  componentWillReceiveProps(props) {\n    this.setState({\n      arr: this.cloneMap(props.data)\n    })\n  }\n\n  resetData(min, max) {\n    Array.from(this.state.arr.values()).map(dataArray => dataArray[0]).forEach((value, index) => {\n      let initial = 0\n      value.data.forEach((obj, index) => {\n        if (min <= obj[0] && max >= obj[0]) {\n          if (!initial) {\n            initial = obj[1]\n            value.data[index - 1] = 0\n          }\n        }\n        if (obj) {\n          obj[1] -= initial\n        }\n      })\n    })\n    this.setState({\n      isReset: true\n    })\n  }\n\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { total, maxIncrement, createdAt } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averagePerDay = total / dateSinceCreated\n            return (\n              <div key={`fork-statistics-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                  <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Total issues\" value={total} prefix={<Icon type=\"info-circle\" />} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Avg. issues/day\" value={averagePerDay} precision={2} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Max. issues/day\" value={maxIncrement} />\n                    </span>\n                  </Row>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready } = this.props\n\n    if (!Array.from(ready.values()).includes(true)) return\n\n    return (\n      <>\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            events: {\n              selection: (event) => {\n                if (!event.resetSelection) {\n                  var min = event.xAxis[0].min;\n                  var max = event.xAxis[0].max;\n                  this.resetData(min, max)\n                } else {\n                  this.setState({\n                    arr: this.cloneMap(data)\n                  })\n                }\n              }\n            },\n            zoomType: 'x',\n            type: 'line'\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'total issues',\n            },\n          },\n          series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n        }}\n      />\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            type: 'column',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'fork increment/day',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[1]),\n        }}\n      />\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._renderStatistics()}\n      {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nFork.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Fork","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Fork extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      isReset: false,\n      arr: []\n    }\n  }\n  static formatter = (repo, data) => {\n    // fprk total data, index 0\n    let total = { name: repo, data: [] }\n    // fork  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n\n    let cumulativeCount = 0\n    data.forEach((value, key) => {\n      cumulativeCount += value\n      total.data.push([key, cumulativeCount])\n      increment.data.push([key, value])\n    })\n\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n\n  cloneMap(map) {\n    let obj = Object.create(null)\n    for (let [k, v] of map) {\n      obj[k] = v\n    }\n    obj = JSON.parse(JSON.stringify(obj))\n    let tmpMap = new Map()\n    for (let k of Object.keys(obj)) {\n      tmpMap.set(k, obj[k])\n    }\n    return tmpMap\n  }\n\n  componentWillReceiveProps(props) {\n    this.setState({\n      arr: this.cloneMap(props.data)\n    })\n  }\n\n  resetData(min, max) {\n    Array.from(this.state.arr.values()).map(dataArray => dataArray[0]).forEach((value, index) => {\n      let initial = 0\n      value.data.forEach((obj, index) => {\n        if (min <= obj[0] && max >= obj[0]) {\n          if (!initial) {\n            initial = obj[1]\n            value.data[index - 1] = 0\n          }\n        }\n        if (obj) {\n          obj[1] -= initial\n        }\n      })\n    })\n    this.setState({\n      isReset: true\n    })\n  }\n\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { total, maxIncrement, createdAt } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averagePerDay = total / dateSinceCreated\n            return (\n              <div key={`fork-statistics-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                  <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Total pull requests\" value={total} prefix={<Icon type=\"pull-request\" />} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Avg. pull requests/day\" value={averagePerDay} precision={2} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Max. pull requests/day\" value={maxIncrement} />\n                    </span>\n                  </Row>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready } = this.props\n\n    if (!Array.from(ready.values()).includes(true)) return\n\n    return (\n      <>\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            events: {\n              selection: (event) => {\n                if (!event.resetSelection) {\n                  var min = event.xAxis[0].min;\n                  var max = event.xAxis[0].max;\n                  this.resetData(min, max)\n                } else {\n                  this.setState({\n                    arr: this.cloneMap(data)\n                  })\n                }\n              }\n            },\n            zoomType: 'x',\n            type: 'line'\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'total pull requests',\n            },\n          },\n          series: Array.from(this.state.arr.values()).map(dataArray => dataArray[0]),\n        }}\n      />\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            type: 'column',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'fork increment/day',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[1]),\n        }}\n      />\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._renderStatistics()}\n      {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nFork.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Fork","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n// import _ from 'lodash'\n\nimport TYPES from './DataTypes'\nimport '../css/DataSection.css'\n\nimport { Progress, Button, Row, Icon, Tag, Popover } from 'antd'\nimport GithubFetcher from '../scripts/GithubFetcher'\n\nimport Repository from './sections/Repository'\nimport Star from './sections/Star'\nimport Fork from './sections/Fork'\nimport Commit from './sections/Commit'\nimport Release from './sections/Release'\nimport Issues from './sections/Issues'\nimport PullRequests from './sections/PullRequests'\n\nclass DataSection extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      progress: new Map(),\n      data: new Map(),\n      stats: new Map(),\n      visible: new Map(),\n      ready: new Map(),\n      loading: false,\n    }\n\n    const { githubApiToken, type } = this.props\n\n    this.fetcher = new GithubFetcher(githubApiToken)\n\n    switch (type) {\n      case TYPES.REPO:\n        this.icon = <Icon type=\"book\" style={{ fontSize: '24px', color: '#333333' }} />\n        this.body = Repository\n        this.fetchCall = this.fetcher.fetchRepositoryData\n        break\n      case TYPES.STAR:\n        this.info = 'Star trend data are huge, they might take minutes to load.'\n        this.icon = <Icon type=\"star\" style={{ fontSize: '24px', color: '#ffb900' }} />\n        this.body = Star\n        this.fetchCall = this.fetcher.fetchStargazerData\n        break\n      case TYPES.FORK:\n        this.icon = <Icon type=\"fork\" style={{ fontSize: '24px', color: '#333333' }} />\n        this.body = Fork\n        this.fetchCall = this.fetcher.fetchForkData\n        break\n      case TYPES.COMMIT:\n        this.info = 'Because of the API restriction, only commits in a recent year will be loaded.'\n        this.icon = <Icon type=\"history\" style={{ fontSize: '24px', color: '#333333' }} />\n        this.body = Commit\n        this.fetchCall = this.fetcher.fetchCommitData\n        break\n      case TYPES.RELEASE:\n        this.icon = <Icon type=\"tag\" style={{ fontSize: '24px', color: '#333333' }} />\n        this.body = Release\n        this.fetchCall = this.fetcher.fetchReleaseData\n        break\n      case TYPES.ISSUES:\n        this.icon = <Icon type=\"info-circle\" style={{ fontSize: '24px', color: '#333333' }} />\n        this.body = Issues\n        this.fetchCall = this.fetcher.fetchIssuesData\n        break\n      case TYPES.PULLREQUESTS:\n        this.icon = <Icon type=\"pull-request\" style={{ fontSize: '24px', color: '#333333' }} />\n        this.body = PullRequests\n        this.fetchCall = this.fetcher.fetchRequestsData\n        break\n      default:\n        console.log('TYPE DOESNOT EXIST')\n        return 'ERROR'\n    }\n\n    // data formatter\n    this.formatter = this.body.formatter\n  }\n\n\n  componentDidUpdate(prevProps) {\n    const { deleteRepo, repos } = this.props\n    const { data, stats, progress, visible, loading, ready } = this.state\n\n    // delete repo out\n    if (deleteRepo !== prevProps.deleteRepo && deleteRepo !== '') {\n      data.delete(deleteRepo)\n      stats.delete(deleteRepo)\n      progress.delete(deleteRepo)\n      ready.delete(deleteRepo)\n      visible.delete(deleteRepo)\n      this.setState({ data, stats, progress, ready, visible, loading: this._getAllProgress() !== 100 && loading && repos.length !== 0 })\n    }\n\n    // new repo in\n    if (prevProps.repos !== repos && deleteRepo === '') {\n      const newRepo = repos.filter(repo => !prevProps.repos.includes(repo))\n      newRepo.forEach(repo => {\n        data.set(repo, {})\n        stats.set(repo, {})\n        progress.set(repo, 0)\n        ready.set(repo, false)\n        visible.set(repo, true)\n        this.setState({ data, stats, progress, ready, visible })\n        if (loading) {\n          this._fetch(repo)\n        }\n      })\n    }\n  }\n\n  /**\n   * fetching from a specific repository\n   * for a specific data type from DataTypes.js\n   * @param repo repo to fectch\n   * @returns exit status string\n   */\n  _fetch = repo => {\n    const { repos } = this.props\n    const slashIndex = repo.indexOf('/')\n    const owner = repo.slice(0, slashIndex)\n    const name = repo.slice(slashIndex + 1)\n\n    const onUpdate = data => {\n      if(this.state.data.has(repo)) {\n        this.state.data.set(\n          repo,\n          this.formatter ? this.formatter(repo, data) : data,\n        )\n        this.setState({ data: this.state.data })\n      }\n    }\n    const onFinish = stats => {\n      if(this.state.stats.has(repo)) {\n        this.state.stats.set(repo, stats)\n        this.state.ready.set(repo, true)\n        this.setState({ stats: this.state.stats, ready: this.state.ready})\n      }\n      if (this._getAllProgress() === 100) {\n        this.setState({ loading: false })\n      }\n    }\n    const onProgress = progress => {\n      if(this.state.progress.has(repo)) {\n        this.state.progress.set(repo,progress)\n        this.setState({\n          progress:this.state.progress\n        })\n      }\n    }\n    const shouldAbort = () => {\n      // if (this._getAllProgress() === 100) {\n      //   this.setState({ loading: false })\n      // }\n      return !repos.includes(repo)\n    }\n\n    this.fetchCall(\n      owner, name,\n      onUpdate,\n      onFinish,\n      onProgress,\n      shouldAbort,\n    )\n\n    return 'FETCH REQUESTED'\n  }\n\n  /**\n   * get progress of fetching all\n   * @returns progress as number from 0 to 100\n   */\n  _getAllProgress = () => {\n    const { progress } = this.state\n    return Math.floor(Array.from(progress.values()).reduce((a, b) => a + b, 0)/ (progress.size === 0 ? 1 : progress.size))\n  }\n\n  _renderUpdateAllButton = () => {\n    const { loading, ready } = this.state\n    const { repos } = this.props\n\n    return (\n      <Button\n        icon=\"cloud-download\"\n        type=\"link\"\n        type=\"primary\"\n        style={{\n          fontSize: '18px',\n          lineHeight: '100%'\n        }}\n        disabled={repos.length === 0}\n        onClick={() => {\n          this.setState({ loading: true })\n          if (this._getAllProgress() === 100) { // re-fetch all\n            repos.forEach(repo => this._fetch(repo))\n          }\n          else { // on fetch unfetched\n            repos.forEach(repo => {\n              if (!ready.get(repo)) {\n                this._fetch(repo)\n              }\n            })\n          }\n        }}\n        loading={loading}\n      >\n        update\n      </Button>\n    )\n  }\n\n  _renderRepoTags = () => {\n    const { progress, visible } = this.state\n    const { repos } = this.props\n\n    return (\n      repos.map(repo => (\n        <div key={\"section-tag\" + repo} style={{ display: 'inline-block'}}>\n          <Progress\n            type=\"circle\"\n            percent={progress.get(repo)}\n            showInfo={false}\n            strokeWidth={8}\n            width={16}\n          />\n          <Tag\n            className=\"repo-tag\"\n            checked={visible.get(repo)}\n            onChange={checked => {\n              visible.set(repo, checked)\n              this.setState({ visible })\n            }}\n          >\n            {repo}\n          </Tag>\n        </div>\n      ))\n    )\n  }\n\n  _renderBody = () => {\n    const { data, stats, ready, loading } = this.state\n    const { repos } = this.props\n\n    return <this.body repos={repos} data={data} stats={stats} ready={ready} loading={loading}/>\n  }\n\n  render() {\n    const { type } = this.props\n\n    return (\n      <div id={type}>\n        <Row type=\"flex\" align=\"middle\" className=\"section-header\">\n          <div className=\"data-card\">\n            {this.icon}\n            <div className=\"section-title\">\n              {type}\n            </div>\n            {this.info ?\n              <Popover className=\"info-tag\" content={this.info} placement=\"left\">\n                <Icon type=\"info-circle\" />\n              </Popover> : null }\n          </div>\n          <div className=\"data-card\"  style={{ marginLeft: 'auto' }}>\n            {this._renderRepoTags()}\n          </div>\n          <Progress\n            type=\"circle\"\n            strokeWidth={4}\n            width={32}\n            percent={this._getAllProgress()}\n          />\n          <div className=\"data-card\">\n            {this._renderUpdateAllButton()}\n          </div>\n        </Row>\n        {this._renderBody()}\n      </div>\n    )\n  }\n\n}\n\nDataSection.propTypes = {\n  githubApiToken: PropTypes.string,\n  repos: PropTypes.array,\n  deleteRepo: PropTypes.string,\n  type: PropTypes.string,\n}\n\nconst mapStateToProps = state => ({\n  githubApiToken: state.github.githubApiToken\n})\n\nexport default connect(\n  mapStateToProps,\n)(DataSection)","import React from 'react'\nimport { connect } from 'react-redux'\nimport PropTypes from 'prop-types'\nimport _ from 'lodash'\n\nimport TYPES from './DataTypes'\nimport COLORS from './sections/Colors'\n\nimport { Row, Col, Anchor, Button, Tag, Tooltip, message, Select } from 'antd'\n\nimport DataSection from './DataSection'\n\nimport GithubFetcher from '../scripts/GithubFetcher'\n\nimport { updateState } from '../actions'\nimport logo from '../image/logo.png'\n// const CENTER_FLEX = { display: 'flex', placeContent: 'center' }\n// const CENTER_LEFT_FLEX = { display: 'flex', justifyContent: 'flex-start', alignContent: 'center'}\n\n// message.config({\n//   top: 60,\n//   duration: 2,\n//   maxCount: 5,\n// })\n\nclass GithubStatistics extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      repos:[],\n      input: undefined,\n      suggestions: [],\n      testingRepo: false,\n      deleteRepo: '',\n    }\n\n    this.fetcher = new GithubFetcher('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')\n\n    this.props.updateState(\"githubApiToken\", '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')\n\n    this.search = _.debounce(\n      this.fetcher.searchRepository,\n      300,\n      { leading: false, trailing: true }\n    ).bind(this)\n  }\n\n  componentDidMount() {\n    try {\n      if (JSON.parse(localStorage.getItem(\"repos\"))) {\n        this.setState({\n          repos: JSON.parse(localStorage.getItem(\"repos\")),\n          deleteRepo: '',\n        })\n      }\n    } catch (error) {\n      console.log(error)\n    }\n  }\n\n  deleteRepo = index => {\n    const { repos } = this.state\n    const deleteRepo = repos[index]\n    repos.splice(index, 1)\n    this.setState({\n      repos: [...repos],\n      deleteRepo: deleteRepo,\n    }, () => {\n      localStorage.setItem(\"repos\", JSON.stringify([...repos]))\n    })\n  }\n\n  addRepo = repo => {\n    const { repos } = this.state\n    if (repos.includes(repo)) {\n      message.error(`${repo} is already added`)\n    }else {\n      this.setState({\n        repos: [ ...repos, repo],\n        deleteRepo: '',\n      }, () => {\n        localStorage.setItem(\"repos\", JSON.stringify([...repos, repo]))\n      })\n    }\n  }\n\n  // _handleAdding = repo => {\n  //   const slashIndex = repo.indexOf('/')\n  //   const owner = repo.slice(0, slashIndex)\n  //   const name = repo.slice(slashIndex + 1)\n\n  //   this.setState({ testingRepo: true })\n  //   this.fetcher.testRepository(owner, name,\n  //     result => {\n  //       this.setState({ testingRepo: false })\n  //       if (result) {\n  //         this.addRepo(repo)\n  //         message.success(repo + ' added')\n  //       } else {\n  //         message.error('Repository not found')\n  //       }\n  //     }\n  //   )\n  // }\n\n  _renderTags = () => {\n    const { repos } = this.state\n\n    return (\n      repos.map((repo, index) => (\n        <Tag key={\"tag\" + repo} color={COLORS[index]} closable onClose={() => this.deleteRepo(index)}>\n          <a target=\"_blank\" rel=\"noopener noreferrer\" href={`https://github.com/${repo}`}>{repo}</a>\n        </Tag>\n      ))\n    )\n  }\n\n  _renderHeaderInput = () => {\n    const { repos, input, testingRepo, suggestions } = this.state\n\n    // const format = /^[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}\\/{1}[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}$/i\n    let hintMessage = ''\n\n    // Conditions\n    const inputEmpty = input === undefined\n    // const formatIncorrect = !format.test(input)\n    const repoExisted = repos.includes(input)\n\n    if (repoExisted) hintMessage = 'Repository already added'\n    // if (formatIncorrect) hintMessage = 'Input incorrectly formatted'\n    if (inputEmpty) hintMessage = 'Empty'\n\n    const disabled = inputEmpty || repoExisted\n\n    return (\n      <React.Fragment>\n        {/* <Input\n          className=\"header-input\"\n          prefix={<Icon type=\"github\"/>}\n          placeholder=\"owner/name\"\n          value={input}\n          onChange={e => {\n            this.setState({ input: e.target.value })\n            this.fetcher.searchRepository(e.target.value, suggestions => this.setState({ suggestions }))\n          }}\n          onPressEnter={() => !disabled && this._handleAdding(input)}\n          disabled={testingRepo}\n          allowClear\n        /> */}\n        <Select\n          className=\"header-input\"\n          value={input}\n          placeholder=\"vesoft-inc/github-statistics\"\n          defaultActiveFirstOption={false}\n          onChange={input => {\n            this.setState({ input })\n            this.addRepo(input)\n          }}\n          onSearch={input => this.search(input, suggestions => this.setState({ suggestions }))}\n          notFoundContent={null}\n          showArrow={false}\n          filterOption={false}\n          showSearch\n        >\n          {suggestions.map(repo => (\n            <Select.Option key={`suggestion-${repo}`} value={repo}>{repo}</Select.Option>\n          ))}\n        </Select>\n        <Tooltip\n          title={hintMessage}\n        >\n          <Button\n            icon=\"plus\"\n            type=\"primary\"\n            loading={testingRepo}\n            disabled={disabled}\n            onClick={() => this.addRepo(input)}\n          />\n        </Tooltip>\n      </React.Fragment>\n    )\n  }\n\n  render() {\n    // const dotStyle = {strokeWidth: 2, r: 2.5}\n    const { repos, deleteRepo } = this.state\n\n    return (\n      <div>\n        <header className=\"header\">\n          <Row type=\"flex\" align=\"middle\">\n            <Col className=\"header-section\">\n              <a className=\"header-title\" href=\"https://github.com/vesoft-inc/github-statistics\" target=\"_blank\">\n                GitHub Stats\n              </a>\n            </Col>\n            <iframe src=\"https://ghbtns.com/github-btn.html?user=vesoft-inc&repo=github-statistics&type=star&count=true\" frameBorder=\"0\" scrolling=\"0\" width=\"100px\" height=\"20px\" />\n            <Col className=\"header-section flex-center\">\n              {this._renderHeaderInput()}\n            </Col>\n            <Col className=\"header-section flex-center-left\">\n              {this._renderTags()}\n            </Col>\n          </Row>\n          <a href=\"https://github.com/vesoft-inc/nebula\" _target=\"_blank\">\n            <img src={logo} alt=\"\" className=\"header-logo\" />\n          </a>\n        </header>\n        <div className=\"container\">\n          <div className=\"sider\">\n            <Anchor bounds={0} className=\"anchor\" offsetTop={70}>\n              {Object.values(TYPES).map(value => (\n                <Anchor.Link key={`anchor-link-${value}`} title={value} href={`#${value}`}/>\n              ))}\n            </Anchor>\n          </div>\n          <div className=\"content\" >\n            <DataSection\n              type={TYPES.REPO}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.STAR}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.FORK}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.COMMIT}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.RELEASE}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n            <DataSection\n              type={TYPES.ISSUES}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n            <DataSection\n              type={TYPES.PULLREQUESTS}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n          </div>\n        </div>\n\n        <footer className=\"footer\">\n        </footer>\n      </div>\n    )\n  }\n}\n\nGithubStatistics.propTypes = {\n  updateState: PropTypes.func,\n}\n\nconst mapDispatchToProps = dispatch => ({\n  updateState: (state, data) => dispatch(updateState(state, data)),\n})\n\nexport default connect(\n  null,\n  mapDispatchToProps,\n)(GithubStatistics)","export const updateState = (state, data) => ({\n  type: 'UPDATE_STATE',\n  payload: { state, data }\n})\n\nexport const updateStatsField = (state, stats) => ({\n  type: 'UPDATE_STATS_FIELD',\n  payload: { state, stats }\n})","import React from 'react'\nimport GithubStatistics from './GithubStatistics'\nimport '../css/App.css'\nclass App extends React.Component {\n  render() {\n    return (\n      <div>\n        <GithubStatistics />\n      </div>\n    )\n  }\n}\n\n\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport reducers from './reducers'\n\nimport './css/normalize.css'\nimport './css/index.css'\nimport App from './components/App'\nimport * as serviceWorker from './serviceWorker'\n\nconst store = createStore(reducers)\nReactDOM.render(\n  <React.Fragment>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.Fragment>\n  ,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}